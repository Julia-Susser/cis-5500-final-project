CREATE INDEX IF NOT EXISTS idx_taxi_pu_location ON taxi(pu_location_id);
CREATE INDEX IF NOT EXISTS idx_taxi_do_location ON taxi(do_location_id);


-- Query 1: Get total taxi pickups and drop-offs
SELECT 
  g.zone, 
  g.location_id, 
  b.borough,
  COUNT(CASE WHEN t.pu_location_id = g.location_id THEN 1 END) AS pickup_count,
  COUNT(CASE WHEN t.do_location_id = g.location_id THEN 1 END) AS dropoff_count
FROM nyc_geometry g
JOIN borough_lut b ON g.borough_id = b.borough_id
LEFT JOIN taxi t ON t.pu_location_id = g.location_id OR t.do_location_id = g.location_id
GROUP BY g.zone, g.location_id, b.borough
ORDER BY pickup_count DESC, dropoff_count DESC;

-- Query 2: Get number of collisions and injuries
SELECT 
  g.zone, 
  g.location_id, 
  b.borough,
  COUNT(c.*) AS collision_count,
  COALESCE(SUM(c.number_of_persons_injured), 0) AS total_injuries
FROM nyc_geometry g
JOIN borough_lut b ON g.borough_id = b.borough_id
LEFT JOIN collision c ON c.borough_id = g.borough_id
GROUP BY g.zone, g.location_id, b.borough
ORDER BY collision_count DESC, total_injuries DESC;

-- Query 3: Get average fare and trip distance
SELECT 
  g.zone, 
  g.location_id, 
  b.borough,
  AVG(t.fare_amount) AS avg_fare,
  AVG(t.trip_distance) AS avg_distance
FROM nyc_geometry g
JOIN borough_lut b ON g.borough_id = b.borough_id
LEFT JOIN taxi t ON t.pu_location_id = g.location_id OR t.do_location_id = g.location_id
GROUP BY g.zone, g.location_id, b.borough
ORDER BY avg_fare DESC, avg_distance DESC;

-- Query 4: Get safety and taxi availability ranking
WITH safety_metrics AS (
  SELECT 
    g.zone, 
    g.location_id, 
    b.borough,
    COUNT(c.*) AS collision_count,
    COALESCE(SUM(c.number_of_persons_injured), 0) AS total_injuries,
    COUNT(CASE WHEN t.pu_location_id = g.location_id THEN 1 END) AS pickup_count
  FROM nyc_geometry g
  JOIN borough_lut b ON g.borough_id = b.borough_id
  LEFT JOIN collision c ON c.borough_id = g.borough_id
  LEFT JOIN taxi t ON t.pu_location_id = g.location_id OR t.do_location_id = g.location_id
  GROUP BY g.zone, g.location_id, b.borough
)
SELECT 
  zone, 
  location_id, 
  borough,
  collision_count,
  total_injuries,
  pickup_count,
  RANK() OVER (ORDER BY collision_count DESC, total_injuries DESC) AS safety_rank,
  RANK() OVER (ORDER BY pickup_count DESC) AS availability_rank
FROM safety_metrics
ORDER BY safety_rank, availability_rank;

-- Query 5: Get valid location IDs (zones with both taxi activity and collisions)
WITH collision_boroughs AS (
  SELECT DISTINCT borough_id
  FROM collision
),
taxi_zones AS (
  SELECT DISTINCT pu_location_id AS location_id FROM taxi
  UNION
  SELECT DISTINCT do_location_id FROM taxi
)
SELECT DISTINCT g.zone, g.location_id, b.borough
FROM nyc_geometry g
JOIN borough_lut b ON g.borough_id = b.borough_id
JOIN collision_boroughs cb ON g.borough_id = cb.borough_id
JOIN taxi_zones tz ON g.location_id = tz.location_id
ORDER BY g.zone;

-- Query 6: Analyze safety by season
SELECT
  CASE
    WHEN EXTRACT(MONTH FROM crash_date) IN (12, 1, 2) THEN 'Winter'
    WHEN EXTRACT(MONTH FROM crash_date) IN (3, 4, 5) THEN 'Spring'
    WHEN EXTRACT(MONTH FROM crash_date) IN (6, 7, 8) THEN 'Summer'
    WHEN EXTRACT(MONTH FROM crash_date) IN (9, 10, 11) THEN 'Fall'
  END AS season,
  COUNT(*) AS collision_count
FROM collision
WHERE crash_date IS NOT NULL
GROUP BY season
ORDER BY collision_count DESC;

-- Query 7: Compute collision rate per 1,000 taxi rides at a location in a date range
-- Example inputs: start_date = '2023-01-01', end_date = '2023-12-31', location_id = 43
WITH collisions_count AS (
  SELECT COUNT(*) AS collisions
  FROM collision c
  JOIN borough_lut b ON c.borough_id = b.borough_id
  JOIN nyc_geometry g ON g.borough_id = b.borough_id
  WHERE c.crash_date BETWEEN '2023-01-01' AND '2023-12-31'
    AND g.location_id = 43
),
taxi_count AS (
  SELECT COUNT(*) AS taxi_rides
  FROM taxi t
  JOIN nyc_geometry g ON t.pu_location_id = g.location_id OR t.do_location_id = g.location_id
  WHERE t.tpep_pickup_datetime BETWEEN '2023-01-01' AND '2023-12-31'
    AND g.location_id = 43
)
SELECT (c.collisions * 1000.0 / NULLIF(t.taxi_rides, 0)) AS collision_rate
FROM collisions_count c, taxi_count t;

-- Query 8: Identify accident spikes in areas with high pickup density
WITH pickup_density AS (
  SELECT pu_location_id, COUNT(*) AS pickups
  FROM taxi
  GROUP BY pu_location_id
  HAVING COUNT(*) > 1000
)
SELECT DATE_TRUNC('month', c.crash_date) AS month, COUNT(*) AS accident_count
FROM collision c
JOIN borough_lut b ON c.borough_id = b.borough_id
JOIN nyc_geometry g ON g.borough_id = b.borough_id
JOIN pickup_density pd ON g.location_id = pd.pu_location_id
GROUP BY month
HAVING COUNT(*) > 100
ORDER BY month;

-- Query 9: Find same collision date-hours
SELECT
  DATE(crash_date) AS date,
  EXTRACT(HOUR FROM crash_time::time) AS hour,
  COUNT(*) AS collision_count
FROM collision
WHERE crash_date IS NOT NULL AND crash_time IS NOT NULL
GROUP BY date, hour
HAVING COUNT(*) > 1
ORDER BY collision_count DESC;

-- Query 10: Fare Analysis - Find areas where fares exceed the city-wide average
WITH average_fare AS (
  SELECT AVG(fare_amount) AS city_avg
  FROM taxi
)
SELECT g.zone, b.borough, AVG(t.fare_amount) AS average_fare
FROM taxi t
JOIN nyc_geometry g ON t.pu_location_id = g.location_id
JOIN borough_lut b ON g.borough_id = b.borough_id
GROUP BY g.zone, b.borough
HAVING AVG(t.fare_amount) > (SELECT city_avg FROM average_fare)
ORDER BY average_fare DESC

-- Query 11: Trip Distance Analysis - Find areas with longer average trip distances
WITH average_distance AS (
  SELECT AVG(trip_distance) AS city_avg
  FROM taxi
)
SELECT g.zone, b.borough, AVG(t.trip_distance) AS average_distance
FROM taxi t
JOIN nyc_geometry g ON t.pu_location_id = g.location_id
JOIN borough_lut b ON g.borough_id = b.borough_id
GROUP BY g.zone, b.borough
HAVING AVG(t.trip_distance) > (SELECT city_avg FROM average_distance)
ORDER BY average_distance DESC

-- Query 12: Peak Hours Analysis - Find peak hours and locations for taxi activity
SELECT g.zone, b.borough, EXTRACT(HOUR FROM t.tpep_pickup_datetime) AS hour, COUNT(*) AS activity_count
FROM taxi t
JOIN nyc_geometry g ON t.pu_location_id = g.location_id
JOIN borough_lut b ON g.borough_id = b.borough_id
GROUP BY g.zone, b.borough, hour
ORDER BY activity_count DESC
LIMIT 10 